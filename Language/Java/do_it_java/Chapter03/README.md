# Chapter 03 - 자바의 여러 가지 연산자

<br>

## Java 기본 연산자

### 항과 연산자

|   연산자    |        설명         |        예시        |
| :---------: | :-----------------: | :----------------: |
| 단항 연산자 | 항이 한 개인 연산자 |       ++num        |
| 이항 연산자 | 항이 두 개인 연산자 |    num1 + num2;    |
| 삼항 연산자 | 항이 세 개인 연산자 | ( 5 > 3 ) ? 1 : 0; |

<br>

추가로, `/`는 몫, `%`는 나머지 !

```java
int num1 = 10;
int num2 = 4;

num1 / num2 = 2; // 몫
num1 % num2 = 2; // 나머지
```

<br>

### 논리 연산 주의점

-   AND(`&&`) 연산 : 둘다 true여야 결과가 true라서 앞에꺼 하나라도 false가 나오면 뒤에 문장을 실행 안하고 false로 확정짓고 넘어감
-   OR(`||`) 연산 : 둘 중 하나만 true여도 겨로가가 true라서 앞에꺼 하나라도 true가 나오면 뒤에꺼 실행 안하고 true로 확정짓고 넘어감

**논리 곱, 논리 합 연산 시 두 항을 모두 실행하지 않더라도 결과 값을 알 수 있는 경우에, 나머지 항이 실행되지 않는 것을 단락 회로 평가(Short Circuit Evaluation; SCE)라고 한다.**

```java
package chapter03;

public class pr03_OperationEx3 {
    public static void main(String[] args) {
        int num1 = 10;
        int i = 2;

        boolean value = ((num1 = num1 + 10) < 10) && ((i = i + 2) < 10);
        System.out.println(value);
        System.out.println(num1);
        System.out.println(i);

        value = ((num1 = num1 + 10) > 10) || ((i = i + 2) < 10);
        System.out.println(value);
        System.out.println(num1);
        System.out.println(i);
    }
}

// false
// 20
// 2    논리 곱, 앞 항 거짓이라서 뒷 항 실행 안되고 i값 그대로
// true
// 30
// 2    논리 합, 앞 항 참이라서 뒷항 실행 안되고 i값 그대로
```

<br>

### 조건 연산자

|         연산자         |                           기능                            |             예시             |
| :--------------------: | :-------------------------------------------------------: | :--------------------------: |
| 조건식 ? 결과1 : 결과2 | 조건식이 참이면 결과 1, <br> 조건식이 거짓이면 결과2 선택 | int num = (5 > 3) ? 10 : 20; |

```java
package chapter03;

public class pr04_OperationEx4 {
    public static void main(String[] args) {
        int num = 10;
        boolean isEven;
        isEven = (num % 2 == 0) ? true : false;
        System.out.println(isEven);
    }
}

// true
```

<br><br>

## Java 비트 연산자

<br>

### 비트 논리 연산자

-   `&` : AND 연산자

```java
  num1 : 0 0 0 0 0 1 0 1 // 5
& num2 : 0 0 0 0 1 0 1 0 // 10
------------------------
result : 0 0 0 0 0 0 0 0 // 0

// 5 & 10 = 0
```

-   `|` : OR 연산자

```java
  num1 : 0 0 0 0 0 1 0 1 // 5
| num2 : 0 0 0 0 1 0 1 0 // 10
------------------------
result : 0 0 0 0 1 1 1 1 // 15

// 5 | 10 = 15
```

-   `^` : XOR 연산자, 같으면 0, 다르면 1

```java
  num1 : 0 0 0 0 0 1 0 1 // 5
^ num2 : 0 0 0 0 1 0 1 0 // 10
------------------------
result : 0 0 0 0 1 1 1 1 // 15

// 5 ^ 10 = 15
```

-   `~` : 반전 연산자, 부호 비트가 1이면 음수인거 까먹지 말기

```java
  num : 0 0 0 0 0 1 0 1 // 10
------------------------
~ num : 1 1 1 1 1 0 1 0 // -11
// ~10 = -11
```

<br>

### 비트 이동 연산자

-   `<<` : 좌측 시프트 연산자, 왼쪽으로 비트 이동, 뒷부분인 오른쪽에 0 채우기

```java
num        : 0 0 0 0 0 1   0 1  // 5
num << 2   : 0 0 0 1 0 1   0 0  // 20
```

왼쪽으로 n비트 이동한다는 것은 **기존 값 \* n<sup>2</sup>** 이다.
따라서, `5 << 2`는 5 \* 2<sup>2</sup> = 20이다.

<br>

-   `>>` : 우측 시프트 연산자, 오른쪽으로 비트 이동, 앞부분인 왼쪽에 0 채우기, 추가로 기존 값의 부호비트와 동일

```java
num        : 0 0 0 0 1 0 1 0 // 10
num >> 2   : 0 0 0 0 0 0 1 0 // 2
```

왼쪽으로 n비트 이동한다는 것은 **기존 값 / n<sup>2</sup>** 이다.
따라서, `10 >> 2`는 10 / 2<sup>2</sup> = 2이다.

<br>

-   `>>>` : 우측 시프트 연산자, 오른쪽으로 비트 이동, 앞부분인 왼쪽에 0 채우기, >>와 다른점은 얘는 기존 값의 부호비트와 상관 없이 무조건 0이 채워짐
